# 時間同步修復說明

## 🐛 問題描述

**用戶報告：**
> 專注時間、短休息、長休息時間沒有同步更新到主頁面，每當我按開始都會跳到 25 分鐘

## 🔍 問題分析

### 根本原因：

發現了兩個問題：

1. **`switchMode()` 缺少 tick 事件**
   - 當用戶切換模式（例如從專注切到短休息）時
   - 雖然內部 `currentData.remainingSeconds` 更新了
   - 但沒有發送 `tickSubject.send(duration)` 事件
   - UI 依賴 `tickPublisher` 來更新顯示時間
   - 結果：UI 顯示舊時間

2. **`updateSettings()` 只在 ready 狀態更新**
   - 如果用戶在 completed 狀態修改設定
   - 時間不會更新
   - 下次啟動時仍使用舊時間

## ✅ 修復方案

### 修復 1: `switchMode()` 添加 tick 事件

**修改檔案：** `TimerEngine.swift`

**修改前：**
```swift
func switchMode(to mode: TimerMode) {
    // ... 其他程式碼 ...

    // Publish state change
    stateSubject.send(.ready)

    // Auto-save
    saveState()
}
```

**修改後：**
```swift
func switchMode(to mode: TimerMode) {
    // ... 其他程式碼 ...

    // Publish state change
    stateSubject.send(.ready)

    // Publish tick to update UI display time  ← 新增這行
    tickSubject.send(duration)

    // Auto-save
    saveState()
}
```

### 修復 2: `updateSettings()` 支援更多狀態

**修改前：**
```swift
// If timer is in ready state, update the remaining time
if currentData.state == .ready {
    let newDuration = timerSettings.duration(for: currentData.mode)
    // ... 更新程式碼 ...
}
```

**修改後：**
```swift
// If timer is NOT running or paused, update the remaining time
if currentData.state == .ready || currentData.state == .completed {
    let newDuration = timerSettings.duration(for: currentData.mode)
    // ... 更新程式碼 ...

    // Publish state change (in case we moved from completed to ready)
    stateSubject.send(.ready)  ← 新增：確保狀態正確

    // Publish tick to update UI
    tickSubject.send(newDuration)
}
```

## 🧪 測試場景

### 場景 1: 修改設定後切換模式

**步驟：**
1. 打開設定，將專注時間改為 30 分鐘
2. 保存設定
3. 返回主畫面
4. ✅ 確認顯示 30:00（而不是 25:00）
5. 切換到短休息
6. ✅ 確認顯示正確的短休息時間

**預期結果：** 所有模式顯示正確的自定義時間

### 場景 2: 完成狀態修改設定

**步驟：**
1. 開始一個專注計時
2. 等待完成（或快轉測試）
3. 計時器顯示「已完成」
4. 打開設定，將專注時間改為 20 分鐘
5. 保存設定
6. 返回主畫面
7. ✅ 確認狀態變為「就緒」
8. ✅ 確認顯示 20:00

**預期結果：** 完成狀態下修改設定也能正確更新

### 場景 3: 自動切換休息時間

**步驟：**
1. 設定專注時間為 30 分鐘
2. 設定短休息為 8 分鐘
3. 選擇「短休息」模式
4. 開始專注並等待完成
5. ✅ 確認自動切換到短休息
6. ✅ 確認顯示 08:00（而不是預設的 05:00）

**預期結果：** 自動切換使用自定義時間

### 場景 4: 運行中不受影響

**步驟：**
1. 開始專注計時（25 分鐘）
2. 計時器運行到 20:00
3. 打開設定，將專注時間改為 30 分鐘
4. 保存設定
5. 返回主畫面
6. ✅ 確認仍顯示 20:00（不受影響）
7. 等待完成或重置
8. ✅ 確認下次開始時使用 30 分鐘

**預期結果：** 運行中的計時器不受設定變更影響

## 📊 技術細節

### Combine Publisher 流程

```
User Changes Settings
    ↓
updateSettings(newSettings)
    ↓
timerSettings = newSettings (更新內部設定)
    ↓
persistence.saveTimerSettings() (保存到 UserDefaults)
    ↓
更新 currentData.remainingSeconds
    ↓
stateSubject.send(.ready) (發布狀態變更)
    ↓
tickSubject.send(newDuration) (發布 tick 事件) ← 關鍵！
    ↓
TimerViewModel 訂閱 tickPublisher
    ↓
displayTime = formatTime(remainingSeconds)
    ↓
UI 更新顯示
```

### 為什麼需要 tick 事件？

TimerViewModel 通過訂閱 `tickPublisher` 來更新 UI：

```swift
// TimerViewModel.swift
timerEngine.tickPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] remainingSeconds in
        self?.displayTime = Self.formatTime(remainingSeconds)
    }
    .store(in: &cancellables)
```

如果不發送 tick 事件，雖然 `currentData.remainingSeconds` 更新了，但 UI 不會收到通知，導致顯示時間不同步。

## 🎯 修復驗證

### 編譯狀態：
```
✅ BUILD SUCCEEDED
```

### 測試清單：
- [ ] 修改專注時間，確認主頁面同步
- [ ] 修改短休息時間，切換模式確認同步
- [ ] 修改長休息時間，切換模式確認同步
- [ ] 完成狀態下修改設定，確認更新
- [ ] 自動切換休息時使用自定義時間
- [ ] 運行中修改設定不影響當前計時
- [ ] 重啟 App 確認設定保留

## 📝 相關檔案

**修改檔案：**
- `TimerEngine.swift` - 修復 `switchMode()` 和 `updateSettings()`

**影響的方法：**
1. `switchMode(to:)` - 添加 tick 事件發布
2. `updateSettings(_:)` - 支援 completed 狀態，添加狀態發布

## 🚀 部署建議

1. **立即測試**：在 Xcode 中運行並測試所有場景
2. **重點測試**：修改設定後切換模式
3. **邊界測試**：在不同狀態下修改設定

## 💡 學習重點

### Reactive Programming 的重要性

在 Reactive 架構中，數據更新必須通過事件通知：

1. **數據層更新** - 更新內部狀態
2. **事件發布** - 發送 Publisher 事件
3. **UI 訂閱響應** - UI 收到事件並更新

缺少任何一步都會導致數據不同步！

### 狀態管理的完整性

修改數據時要考慮：
1. ✅ 內部狀態更新
2. ✅ 狀態事件發布
3. ✅ tick 事件發布（對於時間相關）
4. ✅ 持久化保存

## ✨ 總結

這次修復解決了時間顯示不同步的問題：

✅ **修復 `switchMode()`** - 切換模式時正確更新 UI
✅ **改進 `updateSettings()`** - 更多狀態下都能正確更新
✅ **完善事件發布** - 確保 UI 及時響應數據變化

現在用戶修改時間設定後，主頁面會立即同步顯示正確的時間！🎉
